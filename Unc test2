local totalTests = 0
local passedTests = 0

local function test(name, functions, func)
    totalTests = totalTests + 1
    local success, result = pcall(function()
        return func()
    end)
    if success then
        print(name .. " passed: " .. (result or ""))
        passedTests = passedTests + 1
    else
        print(name .. " failed: " .. result)
    end
end

local function getExecutorLevel()
    -- Dummy function; replace with actual implementation to detect the executor's security level
    return "Level 8"
end

-- Add all test cases here
test("identifyexecutor", {"getexecutorname"}, function()
    local name, version = identifyexecutor()
    assert(type(name) == "string", "Did not return a string for the name")
    assert(type(version) == "string", "Did not return a string for the version")
    return "Executor Name: " .. name .. ", Version: " .. version
end)

test("lz4compress", {}, function()
    local raw = "Hello, world!"
    local compressed = lz4compress(raw)
    assert(type(compressed) == "string", "Compression did not return a string")
    assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
    return "LZ4 compression and decompression passed"
end)

test("lz4decompress", {}, function()
    local raw = "Hello, world!"
    local compressed = lz4compress(raw)
    assert(type(compressed) == "string", "Compression did not return a string")
    assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
    return "LZ4 decompression passed"
end)

test("messagebox", {}, function()
    -- Placeholder test for messagebox
    return "Messagebox test not implemented"
end)

test("queue_on_teleport", {"queueonteleport"}, function()
    return pcall(queueonteleport, function() end) and "Function queued successfully" or "Failed to queue function"
end)

test("request", {"http.request", "http_request"}, function()
    local response = request({
        Url = "https://httpbin.org/user-agent",
        Method = "GET",
    })
    assert(type(response) == "table", "Response must be a table")
    assert(response.StatusCode == 200, "Did not return a 200 status code")
    local data = game:GetService("HttpService"):JSONDecode(response.Body)
    assert(type(data) == "table" and type(data["user-agent"]) == "string", "Did not return a table with a user-agent key")
    return "User-Agent: " .. data["user-agent"]
end)

test("setclipboard", {"toclipboard"}, function()
    setclipboard("Testing Clipboard")
    return "Clipboard set successfully"
end)

test("setfpscap", {}, function()
    local function measureFpsCap(targetFps)
        local renderStepped = game:GetService("RunService").RenderStepped
        local sum = 0
        local count = 0

        setfpscap(targetFps)
        for _ = 1, 5 do
            local startTime = tick()
            renderStepped:Wait()
            local elapsed = tick() - startTime
            sum = sum + (1 / elapsed)
            count = count + 1
        end

        return math.round(sum / count)
    end

    local fps60 = measureFpsCap(60)
    local fps0 = measureFpsCap(0)

    return fps60 .. "fps @60 • " .. fps0 .. "fps @0"
end)

test("getgc", {}, function()
    local gc = getgc()
    assert(type(gc) == "table", "Did not return a table")
    assert(#gc > 0, "Did not return a table with any values")
    return "GC table contains " .. #gc .. " items"
end)

test("getgenv", {}, function()
    getgenv().__TEST_GLOBAL = true
    assert(__TEST_GLOBAL, "Failed to set a global variable")
    getgenv().__TEST_GLOBAL = nil
    return "Global variable set and unset successfully"
end)

test("getloadedmodules", {}, function()
    local modules = getloadedmodules()
    assert(type(modules) == "table", "Did not return a table")
    assert(#modules > 0, "Did not return a table with any values")
    assert(typeof(modules[1]) == "Instance", "First value is not an Instance")
    assert(modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
    return "Loaded modules test passed"
end)

test("getrenv", {}, function()
    assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
    return "Execution environment is isolated"
end)

test("getrunningscripts", {}, function()
    local scripts = getrunningscripts()
    assert(type(scripts) == "table", "Did not return a table")
    assert(#scripts > 0, "Did not return a table with any values")
    assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
    assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
    return "Running scripts retrieved"
end)

test("getscriptbytecode", {"dumpstring"}, function()
    local animate = game:GetService("Players").LocalPlayer.Character.Animate
    local bytecode = getscriptbytecode(animate)
    assert(type(bytecode) == "string", "Did not return a string for Character.Animate")
    return "Bytecode retrieved for Character.Animate"
end)

test("getscripthash", {}, function()
    local animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
    local hash = getscripthash(animate)
    local source = animate.Source
    animate.Source = "print('Hello, world!')"
    task.defer(function()
        animate.Source = source
    end)
    local newHash = getscripthash(animate)
    assert(hash ~= newHash, "Did not return a different hash for a modified script")
    assert(newHash == getscripthash(animate), "Did not return the same hash for a script with the same source")
    return "Hash test passed"
end)

test("getscripts", {}, function()
    local scripts = getscripts()
    assert(type(scripts) == "table", "Did not return a table")
    assert(#scripts > 0, "Did not return a table with any values")
    assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
    assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
    return "Scripts retrieved successfully"
end)

test("getsenv", {}, function()
    local animate = game:GetService("Players").LocalPlayer.Character.Animate
    local env = getsenv(animate)
    assert(type(env) == "table", "Did not return a table for Character.Animate")
    assert(env.script == animate, "The script global is not identical to Character.Animate")
    return "Environment retrieved for Character.Animate"
end)

test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
    assert(type(getthreadidentity()) == "number", "Did not return a number")
    return "Thread identity retrieved"
end)

test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
    setthreadidentity(3)
    assert(getthreadidentity() == 3, "Did not set the thread identity")
    return "Thread identity set to 3"
end)

test("Drawing.new", {}, function()
    local drawing = Drawing.new("Square")
    drawing.Visible = false
    local canDestroy = pcall(function()
        drawing:Destroy()
    end)
    assert(canDestroy, "Drawing:Destroy() should not throw an error")
    return "Drawing creation and destruction test passed"
end)

test("Drawing.Fonts", {}, function()
    assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
    assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
    assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
    assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
    return "Drawing fonts test passed"
end)

test("isrenderobj", {}, function()
    local drawing = Drawing.new("Image")
    drawing.Visible = true
    assert(isrenderobj(drawing) == true, "Did not return true for an Image")
    assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
    return "Render object test passed"
end)

test("getrenderproperty", {}, function()
    local drawing = Drawing.new("Image")
    drawing.Visible = true
    assert(type(getrenderproperty(drawing, "Visible")) == "boolean", "Did not return a boolean value for Image.Visible")
    local success, result = pcall(function()
        return getrenderproperty(drawing, "Color")
    end)
    if not success or not result then
        return "Image.Color is not supported"
    end
    return "Render property retrieval test passed"
end)

test("setrenderproperty", {}, function()
    local drawing = Drawing.new("Square")
    drawing.Visible = true
    setrenderproperty(drawing, "Visible", false)
    assert(drawing.Visible == false, "Did not set the value for Square.Visible")
    return "Render property set successfully"
end)

test("cleardrawcache", {}, function()
    cleardrawcache()
    return "Draw cache cleared"
end)

test("setff", {"setff"}, function()
    -- Placeholder for advanced functionality
    return "setff test not implemented"
end)

test("setsteam", {"setsteam"}, function()
    -- Placeholder for advanced functionality
    return "setsteam test not implemented"
end)

test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
    assert(type(getthreadidentity()) == "number", "Did not return a number")
    return "Thread identity retrieval test passed"
end)

test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
    setthreadidentity(3)
    assert(getthreadidentity() == 3, "Did not set the thread identity")
    return "Thread identity set successfully"
end)

test("setfpscap", {}, function()
    local function measureFpsCap(targetFps)
        local renderStepped = game:GetService("RunService").RenderStepped
        local sum = 0
        local count = 0

        setfpscap(targetFps)
        for _ = 1, 5 do
            local startTime = tick()
            renderStepped:Wait()
            local elapsed = tick() - startTime
            sum = sum + (1 / elapsed)
            count = count + 1
        end

        return math.round(sum / count)
    end

    local fps60 = measureFpsCap(60)
    local fps0 = measureFpsCap(0)

    return fps60 .. "fps @60 • " .. fps0 .. "fps @0"
end)

-- Print Results
local function printResults()
    local percentage = (passedTests / totalTests) * 100
    local level = getExecutorLevel()

    print("\nTotal Tests: " .. totalTests)
    print("Passed Tests: " .. passedTests)
    print("Percentage: " .. string.format("%.2f", percentage) .. "%")

    if percentage >= 80 then
        print("Executor Quality: Excellent")
    elseif percentage >= 60 then
        print("Executor Quality: Good")
    elseif percentage >= 40 then
        print("Executor Quality: Fair")
    else
        print("Executor Quality: Poor")
    end

    print("Executor Security Level: " .. tostring(level))
end

print("Starting Tests...\n")

-- Add all test functions here
printResults()
