repeat task.wait() until game:IsLoaded()

loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/main/Source.lua", true))()

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")

local player = Players.LocalPlayer
local playerCamera = Workspace.CurrentCamera

local TargetedPlayer = nil
local TargetedPlayerCharacter = nil
local TargetedPlayerAimPart = nil
local HighlightedPlayer = nil

local Silent = {
    Settings = {
        Toggled = true,
        AimPart = "UpperTorso",
        HitChance = 9999,
        Prediction = {
            Toggled = true,
            Value = 0,
            AutoPred = true,
            JumpOffset = -0.06,
        },
        Circle = {
            Visible = true,
            Transparency = 0.5,
            Thickness = 3,
            NumSides = 100,
            Radius = 100,
            Filled = false,
        },
        RainbowTarget = true,
        WallCheck = true,
    },
}

local function GetPing()
    return tonumber(Stats.Network.ServerStatsItem["Data Ping"]:GetValueString():match("%d+")) or 0
end

local function UpdatePredictionBasedOnPing()
    if Silent.Settings.Prediction.AutoPred then
        local ping = GetPing()
        if ping < 20 then
            Silent.Settings.Prediction.Value = 0.097285846595
        elseif ping < 30 then
            Silent.Settings.Prediction.Value = 0.10698238794
        elseif ping < 40 then
            Silent.Settings.Prediction.Value = 0.116678929285
        elseif ping < 45 then
            Silent.Settings.Prediction.Value = 0.12251287574925
        elseif ping < 50 then
            Silent.Settings.Prediction.Value = 0.13575
        elseif ping < 55 then
            Silent.Settings.Prediction.Value = 0.1425375
        elseif ping < 60 then
            Silent.Settings.Prediction.Value = 0.124521314351673817351423414
        elseif ping < 65 then
            Silent.Settings.Prediction.Value = 0.1307473800692575082189945847
        elseif ping < 70 then
            Silent.Settings.Prediction.Value = 0.132345567567
        elseif ping < 75 then
            Silent.Settings.Prediction.Value = 0.13896284594535
        elseif ping < 80 then
            Silent.Settings.Prediction.Value = 0.131314253678192031927365421456789331
        elseif ping < 85 then
            Silent.Settings.Prediction.Value = 0.140690614067
        elseif ping < 90 then
            Silent.Settings.Prediction.Value = 0.1355991245213413214231231123121
        elseif ping < 95 then
            Silent.Settings.Prediction.Value = 0.137959574332
        elseif ping < 100 then
            Silent.Settings.Prediction.Value = 0.174857178355
        elseif ping < 105 then
            Silent.Settings.Prediction.Value = 0.138312341526738912
        elseif ping < 110 then
            Silent.Settings.Prediction.Value = 0.1845537197
        elseif ping < 120 then
            Silent.Settings.Prediction.Value = 0.194250261045
        elseif ping < 125 then
            Silent.Settings.Prediction.Value = 0.1512783311111111111111111111111111111111111
        else
            Silent.Settings.Prediction.Value = 0.20394680239
        end
    end
end

task.spawn(function()
    while true do
        UpdatePredictionBasedOnPing()
        task.wait(0)
    end
end)

local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = Silent.Settings.Circle.Visible
FOVCircle.Transparency = Silent.Settings.Circle.Transparency
FOVCircle.Thickness = Silent.Settings.Circle.Thickness
FOVCircle.NumSides = Silent.Settings.Circle.NumSides
FOVCircle.Radius = Silent.Settings.Circle.Radius
FOVCircle.Filled = Silent.Settings.Circle.Filled

local function SmoothColorTransition()
    local hue = 0
    while true do
        for t = 0, 1, 0.01 do
            hue = (hue + 0.01) % 1
            FOVCircle.Color = Color3.fromHSV(hue, 1, 1)
            task.wait(0.01)
        end
    end
end

task.spawn(SmoothColorTransition)

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
end)

local function IsBehindWall(part)
    local rayOrigin = playerCamera.CFrame.Position
    local rayDirection = (part.Position - rayOrigin).Unit * (part.Position - rayOrigin).Magnitude
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {player.Character, part.Parent}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local rayResult = Workspace:Raycast(rayOrigin, rayDirection, rayParams)
    return rayResult ~= nil
end

local function IsPlayerInFront(targetPart)
    local cameraLookVector = playerCamera.CFrame.LookVector
    local directionToTarget = (targetPart.Position - playerCamera.CFrame.Position).Unit
    local dotProduct = cameraLookVector:Dot(directionToTarget)
    return dotProduct > 0
end

local function GetClosestPlayer()
    local ClosestPlayer = nil
    local ShortestDistance = math.huge
    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= player and Player.Character then
            local PlayerPart = Player.Character:FindFirstChild(Silent.Settings.AimPart)
            if PlayerPart and PlayerPart:IsA("BasePart") then
                local PlayerScreenPosition = playerCamera:WorldToViewportPoint(PlayerPart.Position)
                local MagnitudeDistance = (Vector2.new(PlayerScreenPosition.X, PlayerScreenPosition.Y) - Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)).Magnitude
                if MagnitudeDistance <= FOVCircle.Radius and MagnitudeDistance < ShortestDistance and IsPlayerInFront(PlayerPart) then
                    if Silent.Settings.WallCheck then
                        if not IsBehindWall(PlayerPart) then
                            ClosestPlayer = Player
                            ShortestDistance = MagnitudeDistance
                        end
                    else
                        ClosestPlayer = Player
                        ShortestDistance = MagnitudeDistance
                    end
                end
            end
        end
    end
    return ClosestPlayer
end

RunService.RenderStepped:Connect(function()
    TargetedPlayer = GetClosestPlayer()
    if TargetedPlayer and TargetedPlayer.Character and TargetedPlayer.Character:FindFirstChild(Silent.Settings.AimPart) then
        TargetedPlayerCharacter = TargetedPlayer.Character
        TargetedPlayerAimPart = TargetedPlayerCharacter:FindFirstChild(Silent.Settings.AimPart)
        if Silent.Settings.RainbowTarget then
            if not HighlightedPlayer or HighlightedPlayer ~= TargetedPlayer then
                if HighlightedPlayer and HighlightedPlayer.Character then
                    local highlight = HighlightedPlayer.Character:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
                HighlightedPlayer = TargetedPlayer
                local highlight = Instance.new("Highlight", TargetedPlayer.Character)
                highlight.FillColor = Color3.new(1, 0, 0)
                highlight.OutlineColor = Color3.new(1, 1, 1)
                highlight.OutlineTransparency = 0.5
                highlight.FillTransparency = 0.5
                highlight.Adornee = TargetedPlayer.Character
            end
        elseif HighlightedPlayer and HighlightedPlayer ~= TargetedPlayer then
            local highlight = HighlightedPlayer.Character:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
            HighlightedPlayer = nil
        end
    elseif HighlightedPlayer then
        local highlight = HighlightedPlayer.Character:FindFirstChild("Highlight")
        if highlight then
            highlight:Destroy()
        end
        HighlightedPlayer = nil
    end
    FOVCircle.Position = Vector2.new(playerCamera.ViewportSize.X / 2, playerCamera.ViewportSize.Y / 2)
end)

local RawMetaTable = getrawmetatable(game)
local OldRawMetaTable = RawMetaTable.__namecall
setreadonly(RawMetaTable, false)

math.randomseed(os.time())

RawMetaTable.__namecall = newcclosure(function(...)
    local RemoteArguments = {...}
    if Silent.Settings.Toggled and getnamecallmethod() == "FireServer" and TargetedPlayer and TargetedPlayerCharacter and TargetedPlayerAimPart then
        local VelocityPrediction = TargetedPlayerAimPart.AssemblyLinearVelocity * Silent.Settings.Prediction.Value
        local JumpOffset = Vector3.new(0, Silent.Settings.Prediction.JumpOffset, 0)
        local Hit_Success = math.random(100) <= Silent.Settings.HitChance

        for index, arg in ipairs(RemoteArguments) do
            if typeof(arg) == "Vector3" then
                if Hit_Success then
                    if Silent.Settings.Prediction.Toggled then
                        RemoteArguments[index] = TargetedPlayerAimPart.Position + VelocityPrediction + JumpOffset
                    else
                        RemoteArguments[index] = TargetedPlayerAimPart.Position + JumpOffset
                    end
                end
            elseif typeof(arg) == "table" then
                for key, value in pairs(arg) do
                    if typeof(value) == "Vector3" then
                        if Hit_Success then
                            if Silent.Settings.Prediction.Toggled then
                                arg[key] = TargetedPlayerAimPart.Position + VelocityPrediction + JumpOffset
                            else
                                arg[key] = TargetedPlayerAimPart.Position + JumpOffset
                            end
                        end
                    end
                end
            end
        end

        return OldRawMetaTable(unpack(RemoteArguments))
    end
    return OldRawMetaTable(...)
end)

setreadonly(RawMetaTable, true)
